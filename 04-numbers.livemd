<!-- livebook:{"persist_outputs":true} -->

# 4. Working with numbers

```elixir
# Install dependencies
Mix.install([
  :ex_cldr,
  # :ex_cldr_numbers,
  {:ex_cldr_numbers,
   git: "https://github.com/elixir-cldr/cldr_numbers.git", branch: "main", override: true},
  :ex_money,
  :ex_phone_number,
  :jason,
  :phoenix_html
])

# Define a backend module
defmodule DemoApp.Backend do
  use Cldr,
    locales: ["en", "pt", "ja", "hi", "bn", "mr", "te", "ta", "gu"],
    default_locale: "en",
    providers: [Cldr.Number],
    json_library: Jason
end

# Set an app-wide default backend
Application.put_env(:ex_cldr, :default_backend, DemoApp.Backend)

DemoApp.Backend.put_locale("en-US")

:ok
```

<!-- livebook:{"output":true} -->

```

11:59:14.780 [info] Downloaded locale :bn

11:59:15.268 [info] Downloaded locale :gu

11:59:16.133 [info] Downloaded locale :mr

11:59:16.870 [info] Downloaded locale :ta

11:59:17.399 [info] Downloaded locale :te
Generating DemoApp.Backend for 10 locales named [:bn, :en, :gu, :hi, :ja, ...] with a default locale named :en
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Decimals, delimeters and predefined formats

```elixir
# to help a user make sense of large numbers, they should include delimeters
Cldr.Number.to_string!(1_234_567_890)
```

<!-- livebook:{"output":true} -->

```
"1,234,567,890"
```

```elixir
# you may be used to showing one delimeter every three chartacters, but some
# locales have different conventions, e.g. in India:
Cldr.Number.to_string!(1_234_567_890, locale: "hi-IN")
```

<!-- livebook:{"output":true} -->

```
"1,23,45,67,890"
```

```elixir
# the characters used for delimeters (and decimals) often differ by locale, e.g. in Brazil:
Cldr.Number.to_string!(12345.99, locale: "pt-BR")
```

<!-- livebook:{"output":true} -->

```
"12.345,99"
```

```elixir
# we can display numbers in a few predefined formats
Cldr.Number.to_string!(0.12345, format: :standard)
|> IO.puts()

Cldr.Number.to_string!(0.12345, format: :scientific)
|> IO.puts()

Cldr.Number.to_string!(0.12345, format: :percent)
|> IO.puts()
```

<!-- livebook:{"output":true} -->

```
0.123
1.2345E-1
12%
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
# you can list the available formats
Cldr.Number.Format.format_styles_for("en", :latn, DemoApp.Backend)
```

<!-- livebook:{"output":true} -->

```
{:ok,
 [:scientific, :currency, :percent, :accounting, :currency_long, :standard,
  :accounting_alpha_next_to_number, :accounting_no_symbol, :currency_alpha_next_to_number,
  :currency_no_symbol, :currency_short, :decimal_long, :decimal_short]}
```

```elixir
# but there are a few number systems (e.g. Roman, Greek, Japanese, Chinese & Korean) 
# where these format rules wouldn't make sense
Cldr.Number.Format.format_styles_for("ja", :jpan, DemoApp.Backend)
```

<!-- livebook:{"output":true} -->

```
{:ok, []}
```

```elixir
# depending on the locale, a 'native' number system may be used
# e.g. for some of the most popular languages in India:

[
  {"hi-IN", "hindi"},
  {"bn-IN", "bengali"},
  {"mr-IN", "marathi"},
  {"te-IN", "telugu"},
  {"ta-IN", "tamil"},
  {"gu-IN", "gujarati"}
]
|> Enum.each(fn {locale, language} ->
  IO.puts(language)
  IO.puts("\tdefault: " <> Cldr.Number.to_string!(12345, locale: locale))
  IO.puts("\tnative:  " <> Cldr.Number.to_string!(12345, locale: locale, number_system: :native))
  IO.puts("")
end)
```

<!-- livebook:{"output":true} -->

```
hindi
	default: 12,345
	native:  १२,३४५

bengali
	default: ১২,৩৪৫
	native:  ১২,৩৪৫

marathi
	default: १२,३४५
	native:  १२,३४५

telugu
	default: 12,345
	native:  ౧౨,౩౪౫

tamil
	default: 12,345
	native:  ௧௨,௩௪௫

gujarati
	default: 12,345
	native:  ૧૨,૩૪૫

```

<!-- livebook:{"output":true} -->

```
:ok
```

### Monetary values

```elixir
# the currency format is very useful
Cldr.Number.to_string!(1345.32, currency: "USD")
```

<!-- livebook:{"output":true} -->

```
"$1,345.32"
```

```elixir
# the same currency and value might be diplayed differently, depending on the locale
# e.g in Brazil:
Cldr.Number.to_string!(1345.32, locale: "pt-BR", currency: "USD")
```

<!-- livebook:{"output":true} -->

```
"US$ 1.345,32"
```

```elixir
# the 'accounting' format can be used to display negative values in brackets
[
  1345.32,
  -100.00,
  99.95
]
|> Enum.map(fn number ->
  Cldr.Number.to_string!(number, currency: "USD", format: :accounting)
end)
|> Enum.each(&IO.puts/1)
```

<!-- livebook:{"output":true} -->

```
$1,345.32
($100.00)
$99.95
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
# if you are using the ex_money package, you can format money structs 
# a little less verbosely
float_val = 12.50
money_struct = Money.from_float!(:USD, float_val)

Cldr.to_string(money_struct) == Cldr.Number.to_string!(float_val, currency: "USD")
```

<!-- livebook:{"output":true} -->

```
true
```

### Phone numbers

```elixir
# for phone numbers, we need to look outside of CLDR, to the 'ex_phone_number' package
# e.g. a phone number from India
{:ok, phone_number} = ExPhoneNumber.parse("+91 2212345678", nil)
ExPhoneNumber.format(phone_number, :international)
```

<!-- livebook:{"output":true} -->

```
"+91 22 1234 5678"
```

```elixir
# the number can be displayed without the international dialling code
ExPhoneNumber.format(phone_number, :national)
```

<!-- livebook:{"output":true} -->

```
"022 1234 5678"
```

```elixir
# notice how in different countries the numbers are formatted differently
# e.g. for France
{:ok, phone_number} = ExPhoneNumber.parse("+33 109758351", nil)
ExPhoneNumber.format(phone_number, :international)
```

<!-- livebook:{"output":true} -->

```
"+33 1 09 75 83 51"
```

```elixir
# a set of numbers can be cast into a single format,
# e.g. for storing them consistently in a database
[
  "+1 (555) 555-1234",
  "+91 22 1234 5678",
  "+33 1 09 75 83 51"
]
|> Enum.map(fn str_phone_number ->
  ExPhoneNumber.parse(str_phone_number, nil)
end)
|> Enum.map(fn {:ok, phone_number} ->
  ExPhoneNumber.format(phone_number, :e164)
end)
|> Enum.each(&IO.puts/1)
```

<!-- livebook:{"output":true} -->

```
+15555551234
+912212345678
+33109758351
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Ordinals, Roman numerals, words

```elixir
# you may want to show a number as a position (a.k.a. an ordinal number), e.g.

Cldr.Number.to_string!(3, format: :ordinal)
|> IO.puts()

Cldr.Number.to_string!(3, format: :ordinal, locale: "hi-IN")
|> IO.puts()

Cldr.Number.to_string!(3, format: :ordinal, locale: "pt-BR")
|> IO.puts()
```

<!-- livebook:{"output":true} -->

```

12:13:21.241 [warning] ex_cldr_numbers: number format "#,##0" is being compiled. For performance reasons please consider adding this format to the `precompile_number_formats` list in the backend configuration.
3rd
3रा
3º
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
# Roman numerals are sometimes used for naming things, like sections, chapters, or events
("Super Bowl " <> Cldr.Number.to_string!(59, format: :roman))
|> IO.puts()

# they can also useful for displaying a year value in an interresting way
("Since " <> Cldr.Number.to_string!(2008, format: :roman))
|> IO.puts()
```

<!-- livebook:{"output":true} -->

```
Super Bowl LIX
Since MMVIII
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
# and there are certain applications where you may want to spell out numbers explicitly

Cldr.Number.to_string!(1234, format: :spellout)
|> IO.puts()

Cldr.Number.to_string!(1989, format: :spellout_year)
|> IO.puts()

Cldr.Number.to_string!(1234, format: :spellout, locale: "hi-IN")
|> IO.puts()

Cldr.Number.to_string!(1989, format: :spellout_year, locale: "hi-IN")
|> IO.puts()

Cldr.Number.to_string!(1234, format: :spellout, locale: "pt-BR")
|> IO.puts()

Cldr.Number.to_string!(1989, format: :spellout_year, locale: "pt-BR")
|> IO.puts()
```

<!-- livebook:{"output":true} -->

```
one thousand two hundred thirty-four
nineteen eighty-nine
एक हज़ार दो सौ चौंतीस
एक हज़ार नौ सौ नवासी
mil duzentos e trinta e quatro
mil novecentos e oitenta e nove
```

<!-- livebook:{"output":true} -->

```
:ok
```

## Using formatted numbers in markup

```elixir
# you can specify your own wrapper function for adding custom markup to number elements
Cldr.Number.to_string!(5.95,
  format: :currency,
  currency: :USD,
  wrapper: fn
    curr, :currency_symbol -> "<span class=\"text-sm\">" <> curr <> "</span>"
    num, :number -> "<span class=\"text-lg font-semibold\">" <> num <> "</span>"
    el, _other -> el
  end
)
```

<!-- livebook:{"output":true} -->

```
"<span class=\"text-sm\">$</span><span class=\"text-lg font-semibold\">5.95</span>"
```

```elixir
# we suggest using Phoenix.HTML.Tag to ensure valid HTML is generated
Cldr.Number.to_string!(5.95,
  format: :currency,
  currency: :USD,
  wrapper: fn
    curr, :currency_symbol -> Phoenix.HTML.Tag.content_tag(:span, curr, class: "text-sm")
    num, :number -> Phoenix.HTML.Tag.content_tag(:span, num, class: "text-lg font-semibold")
    el, _other -> el
  end
)
```

<!-- livebook:{"output":true} -->

```
"<span class=\"text-sm\">$</span><span class=\"text-lg font-semibold\">5.95</span>"
```
